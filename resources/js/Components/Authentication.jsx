import Cookies from 'universal-cookie';

export const generateRandomBuffer = (length) => {
    const randomBuffer = new Uint8Array(length);
    window.crypto.getRandomValues(randomBuffer); // Fills the buffer with cryptographically secure random values
    return randomBuffer;
}

export const register = async (user) => {
    
    // Generate a unique challenge for the registration process
    const challenge = generateRandomBuffer(32);
    
    // PublicKeyCredentialCreationOptions is the core object needed for registration
    const publicKey = {

        // A random value generated by the server to ensure the request is fresh and unique
        challenge: challenge,

        // Relying Party (your app) information
        rp: {             
            name: "SPAX",
            id: 'protectoraxativa.org'
        },
        // User information        
        user: { 
            id: generateRandomBuffer(16), // A unique identifier for the user
            name: user?.email, // User's email or username
            displayName: user?.name // A friendly name for the user
        },
        // Array of acceptable public key algorithms
        pubKeyCredParams: [
            /*{ 
                type: "public-key",
                alg: -7  // Represents the ES256 algorithm (Elliptic Curve Digital Signature Algorithm)
            }
            */       
            {
                alg: -8,
                type: "public-key"
            },
            {
                alg: -7,
                type: "public-key"
            },
            {
                alg: -257,
                type: "public-key"
            }        
        ],
        // Criteria for selecting the appropriate authenticator
        authenticatorSelection: {
            authenticatorAttachment: "platform", // Ensures we use the device's built-in biometric authenticator like Touch ID or Face ID
            userVerification: "required" // Requires user verification (e.g., fingerprint or face scan)
        },
        timeout: 60000, // Timeout for the registration operation in milliseconds
        attestation: "direct" // Attestation provides proof of the authenticator's properties and is sent back to the server
    }

    try {
        // This will prompt the user to register their biometric credential        
        const credential = await navigator.credentials.create({ publicKey });        

        // Store the credential details on the client and the server
        const credentialJson = storeCredential(credential,challenge);

        //alert("Registration successful! " + JSON.stringify(credential));
        return credentialJson;
    }
    catch(err) {
        // linux firefox
        //console.log(err)     
        // DOMException: The request is not allowed by the user agent or the platform in the current context, possibly because the user denied permission.
        
        //throw err; // Handle any errors that occur during registration
        return false;
    }
}

export const authenticate = async (biometric) => {
    
    if(!biometric?.authentication){
        return null;
    }

    const storedCredential = JSON.parse(biometric.authentication);

    // PublicKeyCredentialRequestOptions is used to prompt the user to authenticate
    const publicKey = {
        
        // A new challenge to ensure the request is fresh and unique
        challenge: new Uint8Array(storedCredential.challenge),

        // Specifies which credentials can be used for authentication
        allowCredentials: [{ 
            id: new Uint8Array(storedCredential.rawId), // The ID of the credential to use
            type: "public-key"
        }],

        // Requires user verification (e.g., fingerprint or face scan)
        userVerification: "required", 

        // Timeout for the authentication operation in milliseconds
        timeout: 60000
    };

    try {
        // This will prompt the user to authenticate using their registered biometric credential
        const credential = await navigator.credentials.get({ publicKey });

        const credentialJson = storeCredential(credential,publicKey.challenge);
        
        //alert("Authentication successful! "+ JSON.stringify(credential));
        return credentialJson;
    }
    catch(err) {
        //console.error("Authentication failed:", err);
        //throw err; // Handle any errors that occur during authentication
        return false;
    }
}

export const storeCredential = (credential,challenge) => {
    
    const credentialData = {
        // Converts the raw ID to an array for storage
        rawId: Array.from(new Uint8Array(credential.rawId)),
        // Converts the challenge to an array for storage
        challenge: Array.from(challenge)
    };

    const credentialJson = JSON.stringify(credentialData); 

    return credentialJson;
}